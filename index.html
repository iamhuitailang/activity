<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>灰太狼的博客 by iamhuitailang</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">灰太狼的博客</h1>
      <h2 class="project-tagline">Activity生命周期(第一部分)</h2>
      <a href="https://github.com/iamhuitailang/activity" class="btn">View on GitHub</a>
      <a href="https://github.com/iamhuitailang/activity/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/iamhuitailang/activity/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p><code>Activity生命周期(第一部分)</code></p>

<p>所谓生命周期，就是简单说就是出生到死亡这一循环经历的东西；人有生命周期：出生、幼年、少年、青年、壮年、中年、老年这一生命过程；
扯多了。。。。，但是对于Android开发来说，activity的生命周期是你必须要掌握的东西，如果你连一个你要开发的东西的周期都不明白的那才真是活的回去了。</p>

<p><code>简单一下流程（目前还无法上传图片，这个周之内会把图片上传上来，关于activity生命周期的一个流程图）</code></p>

<p><code>Activity生命周期最主要的一些方法，启动后依次执行：onCreate –&gt; onStart –&gt; onResume –&gt; onPause –&gt; onStop –&gt; onDestroy</code>
<code>借用网上的一些资料来解释一下这几个主要的生命周期：</code></p>

<p><code>1. void onCreate(Bundle savedInstanceState)</code>
<code>当Activity被第首次加载时执行。我们新启动一个程序的时候其主窗体的onCreate事件就会被执行。如果Activity被销毁后（onDestroy后），再重新加载进Task时，其onCreate事件也会被重新执行。注意这里的参数 savedInstanceState（Bundle类型是一个键值对集合，大家可以看成是.Net中的Dictionary）是一个很有用的设计，由于前面已经说到的手机应用的特殊性，一个Activity很可能被强制交换到后台（交换到后台就是指该窗体不再对用户可见，但实际上又还是存在于某个Task中的，比如一个新的Activity压入了当前的Task从而“遮盖”住了当前的 Activity，或者用户按了Home键回到桌面，又或者其他重要事件发生导致新的Activity出现在当前Activity之上，比如来电界面），而如果此后用户在一段时间内没有重新查看该窗体（Android通过长按Home键可以选择最近运行的6个程序，或者用户直接再次点击程序的运行图标，如果窗体所在的Task和进程没有被系统销毁，则不用重新加载，直接重新显示Task顶部的Activity，这就称之为重新查看某个程序的窗体），该窗体连同其所在的 Task和Process则可能已经被系统自动销毁了，此时如果再次查看该窗体，则要重新执行 onCreate事件初始化窗体。而这个时候我们可能希望用户继续上次打开该窗体时的操作状态进行操作，而不是一切从头开始。例如用户在编辑短信时突然来电，接完电话后用户又去做了一些其他的事情，比如保存来电号码到联系人，而没有立即回到短信编辑界面，导致了短信编辑界面被销毁，当用户重新进入短信程序时他可能希望继续上次的编辑。这种情况我们就可以覆写Activity的void onSaveInstanceState(Bundle outState)事件，通过向outState中写入一些我们需要在窗体销毁前保存的状态或信息，这样在窗体重新执行onCreate的时候，则会通过 savedInstanceState将之前保存的信息传递进来，此时我们就可以有选择的利用这些信息来初始化窗体，而不是一切从头开始。</code></p>

<p><code>2. void onStart()   activity变为在屏幕上对用户可见时调用。</code>
<code>onCreate事件之后执行。或者当前窗体被交换到后台后，在用户重新查看窗体前已经过去了一段时间，窗体已经执行了onStop事件，但是窗体和其所在进程并没有被销毁，用户再次重新查看窗体时会执行onRestart事件，之后会跳过onCreate事件，直接执行窗体的onStart事件。</code></p>

<p><code>3. void onResume()   activity开始与用户交互时调用（无论是启动还是重新启动一个活动，该方法总是被调用的）。</code>
<code>onStart事件之后执行。或者当前窗体被交换到后台后，在用户重新查看窗体时，窗体还没有被销毁，也没有执行过onStop事件（窗体还继续存在于Task中），则会跳过窗体的onCreate和onStart事件，直接执行onResume事件。</code></p>

<p><code>4. void onPause()   activity被暂停或收回cpu和其他资源时调用，该方法用于保存活动状态的，也是保护现场，压栈吧！</code>
<code>窗体被交换到后台时执行。</code></p>

<p><code>5. void onStop()    activity被停止并转为不可见阶段及后续的生命周期事件时调用。</code>
<code>onPause事件之后执行。如果一段时间内用户还没有重新查看该窗体，则该窗体的onStop事件将会被执行；或者用户直接按了Back键，将该窗体从当前Task中移除，也会执行该窗体的onStop事件。</code></p>

<p><code>6. void onRestart()   重新启动activity时调用。该活动仍在栈中，而不是启动新的活动。</code>
<code>onStop事件执行后，如果窗体和其所在的进程没有被系统销毁，此时用户又重新查看该窗体，则会执行窗体的onRestart事件，onRestart事件后会跳过窗体的onCreate事件直接执行onStart事件。</code></p>

<p><code>7. void onDestroy()   activity被完全从系统内存中移除时调用，该方法被调用可能是因为有人直接调用onFinish()方法或者系统决定停止该活动以释放资源！</code>
<code>Activity被销毁的时候执行。在窗体的onStop事件之后，如果没有再次查看该窗体，Activity则会被销毁。</code></p>

<p><code>很多人也都已经知道以上方法与执行顺序，但是Activity还有其他方法，如onContentChanged， onPostCreate， onPostResume， onConfigurationChanged， onSaveInstanceState，onRestoreInstanceState；大家是不是想试一下关于这些生命周期的执行顺序，那咱们就看接下来的这个例子，比较简单，但是一目了然：</code></p>

<p><code>public class ActivityLife extends Activity {</code></p>

<p><code>static String TAG = "ActivityLife";</code></p>

<p><code>@Override</code>
<code>public void onCreate(Bundle savedInstanceState) {</code></p>

<p><code>super.onCreate(savedInstanceState);</code>
<code>Log.d(TAG, "onCreate");</code>
<code>setContentView(R.layout.activity_demo);</code>
<code>}</code></p>

<p><code>@Override</code>
<code>public void onContentChanged() {</code>
<code>super.onContentChanged();</code>
<code>Log.d(TAG, "onContentChanged");</code></p>

<p><code>}</code></p>

<p><code>public void onStart() {</code>
<code>super.onStart();</code>
<code>Log.d(TAG, "onStart");</code>
<code>}</code></p>

<p><code>public void onRestart() {</code>
 <code>super.onRestart();</code>
<code>Log.d(TAG, "onRestart");</code>
<code>}</code></p>

<p><code>public void onPostCreate(Bundle savedInstanceState) {</code>
<code>super.onPostCreate(savedInstanceState);</code>
<code>Log.d(TAG, "onPostCreate");</code>
<code>}</code></p>

<p><code>@Override</code>
<code>public void onResume() {</code>
<code>super.onResume();</code>
<code>Log.d(TAG, "onResume");</code>
<code>}</code></p>

<p><code>public void onPostResume() {</code>
<code>super.onPostResume();</code>
<code>Log.d(TAG, "onPostResume");</code>
<code>}</code></p>

<p><code>public void onPause() {</code>
<code>super.onPause();</code>
<code>Log.d(TAG, "onPause");</code>
<code>}</code></p>

<p><code>public void onStop() {</code>
<code>super.onStop();</code>
<code>Log.d(TAG, "onStop");</code>
<code>}</code></p>

<p><code>public void onDestroy() {</code>
<code>super.onDestroy();</code>
<code>Log.d(TAG, "onDestroy");</code>
<code>}</code></p>

<p><code>public void onConfigurationChanged(Configuration newConfig) {</code>
<code>super.onConfigurationChanged(newConfig);</code>
<code>Log.d(TAG, "onConfigurationChanged");</code>
<code>}</code></p>

<p><code>public void onSaveInstanceState(Bundle outState) {</code>
<code>super.onSaveInstanceState(outState);</code>
<code>Log.d(TAG, "onSaveInstanceState");</code>
<code>}</code></p>

<p><code>public void onRestoreInstanceState(Bundle outState) {</code>
<code>super.onRestoreInstanceState(outState);</code>
<code>Log.d(TAG, "onRestoreInstanceState");</code>
<code>}</code>
<code>}</code></p>

<p><code>程序运行结果出来了，不知道大家心里是否也有一个结果，生命周期的方法执行顺序是这样的：</code>
<code>onCreate –&gt; onContentChanged –&gt; onStart –&gt; onPostCreate –&gt; onResume –&gt; onPostResume –&gt; onPause –&gt; onStop –&gt; onDestroy</code></p>

<p>下面是对一些生命周期的解释和比较:
<code>onContentChanged</code></p>

<p><code>onContentChanged()是Activity中的一个回调方法 当Activity的布局改动时，即setContentView()或者addContentView()方法执行完毕时就会调用该方法， 例如，Activity中各种View的findViewById()方法都可以放到该方法中。</code></p>

<p><code>onPostCreate、onPostResume</code></p>

<p><code>onPostCreate方法是指onCreate方法彻底执行完毕的回调，onPostResume类似，这两个方法官方说法是一般不会重写，现在知道的做法也就只有在使用ActionBarDrawerToggle的使用在onPostCreate需要在屏幕旋转时候等同步下状态，Google官方提供的一些实例就是如下做法：
</code>
<code>@Override</code>
<code>protected void onPostCreate(Bundle savedInstanceState) {</code>
<code>super.onPostCreate(savedInstanceState);</code></p>

<p><code>// Sync the toggle state after onRestoreInstanceState has occurred.</code>
<code>mDrawerToggle.syncState();</code></p>

<p><code>}</code></p>

<p><code>onPause、 onStop</code></p>

<p><code>这里顺便再提一下onPause、 onStop的区别， onPause是在整个窗口被半遮盖或者半透明的时候会执行，个人感觉在onPause中进行数据的保存时比较合适的；而onStop则是在整个窗口被完全遮盖才会触发， 触发onStop的方法之前必定会触发onPause方法。</code></p>

<p><code>onCreate、 onStart</code></p>

<p><code>onCreate方法会在第一次创建的时候执行，紧接着便会执行onStart方法，之后页面被完全遮挡会执行onStop方法，再返回的时候一般便会执行onRestart –&gt; onStart方法， 但是如果如果这时候App内存不够需要更多的内存的时候，App便会杀死该进程，结束掉该Activity，所以这时候再返回的时候便会重新执行onCreate –&gt; onStart –&gt; onResume方法。</code></p>

<p><code>onSaveInstanceState</code></p>

<p><code>onSaveInstanceState字面理解就是保存实例的状态，当某个activity变得“容易”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户主动销毁的，例如当用户按BACK键的时候。</code></p>

<p><code>注意上面的双引号，何为“容易”？言下之意就是该activity还没有被销毁，而仅仅是一种可能性。这种可能性有这么几种情况：</code></p>

<p><code>1、当用户按下HOME键时</code>
<code>这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activityA是否会被销毁，故系统会调用onSaveInstanceState，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则</code></p>

<p><code>2、长按HOME键，选择运行其他的程序时。</code></p>

<p><code>3、按下电源按键（关闭屏幕显示）时。</code></p>

<p><code>4、从activity A中启动一个新的activity时。</code></p>

<p><code>5、屏幕方向切换时，例如从竖屏切换到横屏时。</code>
<code>在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行</code>
<code>总而言之，onSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用，这是系统的责任，因为它必须要提供一个机会让你保存你的数据（当然你不保存那就随便你了）。</code></p>

<p><code>onRestoreInstanceState</code></p>

<p><code>onSaveInstanceState字面理解就是恢复实例的状态, 需要注意的是，onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的，onRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activityA的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activityA，这种情况下activityA一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。</code></p>

<p><code>不过大多数情况下也是很少使用onRestoreInstanceState方法的，经常我们还是在onCreate方法里直接恢复状态的，onCreate方法里本身会有一个Bundle参数的，很多时候我们是这样使用的。（onCreate在onStart之前调用，而onRestoreInstanceState是在onStart之后调用）</code></p>

<p>本来是想多写一篇的，谁知今天游泳游的太Happy，身体跟不上节奏了，0.0，下次在写。</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/iamhuitailang/activity">灰太狼的博客</a> is maintained by <a href="https://github.com/iamhuitailang">iamhuitailang</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
